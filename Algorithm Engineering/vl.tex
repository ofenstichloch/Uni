\documentclass[a4paper]{article}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{fancyhdr}
\usepackage{a4wide}
\usepackage{geometry}
\usepackage[utf8]{inputenc}
\geometry{a4paper,left=2cm,right=2cm, top=3cm, bottom=3cm}
\usepackage{listings}

\newcommand{\titel}[1]{\fancyhead[C]{#1}}
\newcommand{\name}{\fancyhead[L]{Alexander Landmesser}}
\newcommand{\matrikel}{\fancyhead[R]{Matrikelnummer: 1096552}}
\newcommand{\pl}{\hspace*{1cm}}
\begin{document}
\title{Algorithm Engineering}
\maketitle
\section{Datentypen}

\subsubsection*{Getränkeautomat}
Automat akzeptiert 1E, ein Getränk kostet 3E\\
Operatoren:
\begin{enumerate}
\item Init(Reset)
\item Akzeptiere1E
\end{enumerate}
Init $\rightarrow$ Zustand\\
\hspace*{0.5cm}Semantik: Automat geht in Zustand 0\\
Akzeptiere1E: ZustandX\{0,1\} $\rightarrow$ ZustandX\{tue nichts, gib Getänk\}\\
\hspace*{0.5cm}Semantik: Beschreibung durch einen endlichen Automaten.
\subsubsection*{Stadtplan}
Übung 1
\subsection{Bemerkungen}
\begin{itemize}
\item Operatoren können partiell Definiert sein. Man gibt Definitionsbereich oft in einer Vorbedingung an.
\item Operatoren, bei denen der Datentyp selbst auf der linken Seite nicht vorkommt, heißen \underline{Konstruktoren}. Sie erzeugen ein neues Objekt (bzw. versetzen den Typ in einem bestimmten Zustand).
	\begin{itemize}
		\item Create: $\rightarrow$ stack$<$T$>$
		\item Create: int $\rightarrow$ vector (Vektor bestimmter Dimension)
	\end{itemize}
\item Objekt- und Zustandssicht sind beide nützlich. \underline{Stack/Getränkeautomat} haben internen Zustand, Operatoren können ihn verändern.
	\begin{itemize}
		\item Integer: Objektsicht besser, Operatoren erzeugen neue Objekte, exisitierende werden nicht geändert.
	\end{itemize}
\item stack$<T>$ ist ein parametrisierbarer Datentyp: Stack mit Elementen vom Typ T. Hat eventuell besondere Anforederungen an Typ T, z.B. $x\leq y$ in Dictionaries.
\item Man kann nun eigentlich schon programmieren, obwohl über die Interpretiernug noch nichts bekannt ist.

\end{itemize}
\subsubsection*{Anwendung von stack$<T>$}
Auswertung von Postfix-Ausdrücken\\
Vereinfachungen: alle Operatoren binär (+-*/), Eingabe nur Zahlen 0-9\\
\underline{Bsp.:} $(7-5)*(3+1)\rightarrow 75-31+*$
\subsection{Defintion eines Datentyps}
(In einer Objekt-Orientierten Programmiersprache)\\
\begin{lstlisting}[language=c++]
class Typname {
	//Definition der Menge der Objekte bzw Zustaende
	private: //Deklaration von Variablen zur Darstellung der Objekte/Zustaende
	public: //Operatoren
	//Kommentare z.B. ueber Effizienz
};
\end{lstlisting}
\subsubsection*{Operatoren}
Methoden/Memberfunktionen\\
Syntax: Ergebnistyp Name(Argumente...);\\
\underline{Spezielle Methoden:} 
\begin{itemize}
	\item Kein Ergebnistyp: stack(); stack(size);
	\item Destruktor: $\sim$ Typname();
\end{itemize}
\subsection{Beispiel}
int\_stack $\rightarrow$ stack$<T>$\\
\begin{lstlisting}[language=c++]
class int_stack {
	/* Eine Instanz vom Typ int_stack ist eine Folge von ganzen Zahlen (int). Eine Folge der laenge 0 heisst der leere Stack.*/
	private: //Implementierung
	public: stack(int sz); //Konstruktor
	//Erzeugt einen Stack mit maximaler Groesse sz
	~stack() //Destruktor
	void push (int x);
	//fuegt x als letzes Element (top) an die Folge an.
	int top() const;
	//liefert das letzte (top) Element
	//Precondition: Stack nicht leer
	int pop();
	//entfernt letztes (top) Element der Folge und gibt es zurueck
	//Precondition: Stack nicht leer
	bool empty() const;
	//true, wenn Stack leer, false sonst.
	
\end{lstlisting}
In c++ Spezielle Header Datei, die die Deklarationen ohne Rumpf enthält. Implementierung in .cpp\\
\subsubsection*{Implementierung der Klasse int\_stack}
Mehrere Möglichkeiten: Array, Liste
Array Implementierung:
$int_stack.h$
\begin{lstlisting}
class int_stack {
	private 
		int* A; //Feld
		int sz; //Laenge von A
		int t;
};
\end{lstlisting}
$int_stack.cpp$
\begin{lstlisting}[escapechar=!]
#include "int_stack.h"
int_stack::int_stack(int n) {
	sz=2;
	A = new int[sz];
	t = -1; //leer
}
int_stack::~int_stack(){
	delete[] A;
}
void int_stack::push(int x){
	if (t == sz-1){
		//stack voll
		int* B=new int[2*sz];
		sz !$\leftarrow$! 2*sz;
		for(int i=0; i !$\leq $!;i++){
			B[i] !$\leftarrow $!
		}
		delete[] A;
	}
	A[++t] !$\leftarrow $! x; //eigentlich push
}
int int_stack::pop(){
	if(t==-1){
		EXCEPTION("Leerer Stack")
	return A[t--];
}

\end{lstlisting}
\subsubsection*{Einschub: Variablen, Konstruktoren, Wertzuweisung}
%TODO Einrückung!
\begin{itemize}
\item[Variablen Deklaration] c++: Aufruf des Konstruktors generiert ein Objekt.\\
	Java: Erst eine Referenz erstellen, dann ein Objekt generieren und auf dieses verweisen.
\item[Wertzuweisung] c++: $int_stack s1,s2; s1=s2;$ Objekt wird kopiert, es gibt 2 Objekte.\\
	Java: $int_stack s1,s1; s1=s2;$ Referenzen zeigen auf ein einziges Objekt.
\item[Referenzsemantik in c++:] Verwendet Pointer auf ein Objekt.\\
	Test auf Gleichheit (==) Operator\\
	Parameterübergabe sind Pointer
\item[Referenzsemantik in Java:] Parameter by Value, gesamtes Objekt kopiert und dann übergeben.
\end{itemize}
\subsection*{Korrektheit einer Implementierung}
(Hier der Array-Implementierung von $int_stack$)\\
Eigentlich 2 Datentypen:
\begin{itemize}
\item[1.] der abstrake Datentyp $int_stack$
\item[2.] der konkrete Datentyp Array
\end{itemize}
\underline{Abstrakter Zustand:} Folge von int's\\
\underline{Konkreter Zustand:} Werte der Variable A,t,sz\\
Wir garantieren (Invariante), dass nicht die Kombination von A,t,sz möglich sind, sondern nur gültige Zustande mit:
\begin{itemize}
\item[1.]A ist ein Feld der Länge sz
\item[2.] $-1 \leq t\leq sz-1$
\end{itemize}
Sei Z=Menge der konkreten Zustände und S = Menge der abstrakten Zustände\\
Um die Korrektheit zu zeigen, definieren wir eine Abbildung $F: Z \rightarrow S$\\
$(A,sz,t) \rightarrow \left\lbrace \begin{array}{l}
	Folge\ A[0],...,A[t]\ falls t\geq 0\\
	Leere\ Folge, t=-1
\end{array}\right.$
Und zeigen:
\begin{itemize}
\item[1.] Konstruktoren erzeugen gültige konkrete Zustände
\item[2.] Für jede abstrakte Operation und die dazugehörige konkrete Operation $f_{op}$ zeige $F(f_{op}(Z)) = op(F(Z))$
	Bsp.: push: $S\times int \rightarrow S $\\
	$f_{push}: Z \times int \rightarrow Z$
\end{itemize}
Kommutatives Diagramm:\\
$z \xrightarrow{F} s$\\
$\downarrow f_{op} \uparrow op$\\
$z' \xrightarrow{F} s'$
\subsection*{Vererbung/Generische Datentypen}
Templates/Wiederverwendung von Code\\
\underline{Situation}\\
Man braucht einen Datentyp A, der sehr ähnlich zu einem bereits vorhandenen definierten Typ B ist.\\
A soll:\\
\begin{itemize}
\item einen Teil der Daten/Operationen verwenden
\item andere Daten/Operationen anfügen
\item einige verändern (auf andere Weise implementieren)
\end{itemize}
\subsubsection*{Beispiel}
Es existiert die Klasse Polygon (B), implementiert werden soll eine Klasse Rechteck (A).\\
A ist eine Spezialisierung von B\\
Rechteck könnte alle Polygon-Operationen (draw(),translte etc)\\
Einige Operationen können effizienter implementiert werden (Flächeninhalt etc.)\\
Andere sind nur für Rechtecke definiert.\\
Jedes Rechteck ist ein spezielles Polygon.
\subsubsection*{Allgemein}
Wir leiten die Klasse A von der Klasse B ab.\\
Syntax in c++: A: public B\\
\begin{lstlisting}
class Rechteck: public Polygon{
	//Konstruktoren -> uebung :(
	private:
		//Ueberschreiben
		double b,h;
		double area() {return b*h;}
		double umfang() {return 2*(b+h);}
		//Hinzufuegen
		double ratio() {return b/h;}
};
\end{lstlisting}
Ableitungen auch als Baum darstellbar (Shape mit Kindern Polygon/Ellipse/Punkt etc)\\
\subsubsection*{Typverträglichkeit}
Einer Variable vom Typ B* oder B\& (alle Variablen in JAVA vom Typ B) kann ein Opbjekt (Pointer/Referenz) vom Typ A zugewiesen werden.\\
Alle im Ableitungsbaum erreichbaren Typen können zugewiesen werden (Kinder).\\
Eine Variable hat 2 Typen: Einen Statischen Typ, der zur Compilezeit bekannt ist. Dynamischer Typ, der zur Laufzeit bekannt ist.
\subsection*{Polymorphe Datenstrukturen}
Bsp.: Feld von Polygonen\\
c++: Polygon** (Ein Pointer auf ein Feld von Pointern) A = new Polygon*[100];\\
A[0] = new Polygon(...);\\
A[1] = new Rechteck(...);\\
\end{document}