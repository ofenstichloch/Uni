\documentclass[a4paper]{article}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{fancyhdr}
\usepackage{a4wide}
\usepackage{geometry}
\usepackage[utf8]{inputenc}
\geometry{a4paper,left=2cm,right=2cm, top=3cm, bottom=3cm}
\usepackage{listings}

\newcommand{\titel}[1]{\fancyhead[C]{#1}}
\newcommand{\name}{\fancyhead[L]{Alexander Landmesser}}
\newcommand{\matrikel}{\fancyhead[R]{Matrikelnummer: 1096552}}
\newcommand{\pl}{\hspace*{1cm}}
\begin{document}
\title{Algorithm Engineering}
\maketitle
\section*{Datentypen}

\subsubsection*{Getränkeautomat}
Automat akzeptiert 1E, ein Getränk kostet 3E\\
Operatoren:
\begin{enumerate}
\item Init(Reset)
\item Akzeptiere1E
\end{enumerate}
Init $\rightarrow$ Zustand\\
\hspace*{0.5cm}Semantik: Automat geht in Zustand 0\\
Akzeptiere1E: ZustandX\{0,1\} $\rightarrow$ ZustandX\{tue nichts, gib Getänk\}\\
\hspace*{0.5cm}Semantik: Beschreibung durch einen endlichen Automaten.
\subsubsection*{Stadtplan}
Übung 1
\subsection*{Bemerkungen}
\begin{itemize}
\item Operatoren können partiell Definiert sein. Man gibt Definitionsbereich oft in einer Vorbedingung an.
\item Operatoren, bei denen der Datentyp selbst auf der linken Seite nicht vorkommt, heißen \underline{Konstruktoren}. Sie erzeugen ein neues Objekt (bzw. versetzen den Typ in einem bestimmten Zustand).
	\begin{itemize}
		\item Create: $\rightarrow$ stack$<$T$>$
		\item Create: int $\rightarrow$ vector (Vektor bestimmter Dimension)
	\end{itemize}
\item Objekt- und Zustandssicht sind beide nützlich. \underline{Stack/Getränkeautomat} haben internen Zustand, Operatoren können ihn verändern.
	\begin{itemize}
		\item Integer: Objektsicht besser, Operatoren erzeugen neue Objekte, exisitierende werden nicht geändert.
	\end{itemize}
\item stack$<T>$ ist ein parametrisierbarer Datentyp: Stack mit Elementen vom Typ T. Hat eventuell besondere Anforederungen an Typ T, z.B. $x\leq y$ in Dictionaries.
\item Man kann nun eigentlich schon programmieren, obwohl über die Interpretiernug noch nichts bekannt ist.

\end{itemize}
\subsubsection*{Anwendung von stack$<T>$}
Auswertung von Postfix-Ausdrücken\\
Vereinfachungen: alle Operatoren binär (+-*/), Eingabe nur Zahlen 0-9\\
\underline{Bsp.:} $(7-5)*(3+1)\rightarrow 75-31+*$
\subsection*{Defintion eines Datentyps}
(In einer Objekt-Orientierten Programmiersprache)\\
\begin{lstlisting}[language=c++]
class Typname {
	//Definition der Menge der Objekte bzw Zustaende
	private: //Deklaration von Variablen zur Darstellung der Objekte/Zustaende
	public: //Operatoren
	//Kommentare z.B. ueber Effizienz
};
\end{lstlisting}
\subsubsection*{Operatoren}
Methoden/Memberfunktionen\\
Syntax: Ergebnistyp Name(Argumente...);\\
\underline{Spezielle Methoden:} 
\begin{itemize}
	\item Kein Ergebnistyp: stack(); stack(size);
	\item Destruktor: $\sim$ Typname();
\end{itemize}
\subsection*{Beispiel}
int\_stack $\rightarrow$ stack$<T>$\\
\begin{lstlisting}[language=c++]
class int_stack {
	/* Eine Instanz vom Typ int_stack ist eine Folge von ganzen Zahlen (int). Eine Folge der laenge 0 heisst der leere Stack.*/
	private: //Implementierung
	public: stack(int sz); //Konstruktor
	//Erzeugt einen Stack mit maximaler Groesse sz
	~stack() //Destruktor
	void push (int x);
	//fuegt x als letzes Element (top) an die Folge an.
	int top() const;
	//liefert das letzte (top) Element
	//Precondition: Stack nicht leer
	int pop();
	//entfernt letztes (top) Element der Folge und gibt es zurueck
	//Precondition: Stack nicht leer
	bool empty() const;
	//true, wenn Stack leer, false sonst.
	
\end{lstlisting}
In c++ Spezielle Header Datei, die die Deklarationen ohne Rumpf enthält. Implementierung in .cpp\\
\subsubsection*{Implementierung der Klasse int\_stack}
Mehrere Möglichkeiten: Array, Liste
Array Implementierung:
$int_stack.h$
\begin{lstlisting}
class int_stack {
	private 
		int* A; //Feld
		int sz; //Laenge von A
		int t;
};
\end{lstlisting}
$int_stack.cpp$
\begin{lstlisting}[escapechar=!]
#include "int_stack.h"
int_stack::int_stack(int n) {
	sz=2;
	A = new int[sz];
	t = -1; //leer
}
int_stack::~int_stack(){
	delete[] A;
}
void int_stack::push(int x){
	if (t == sz-1){
		//stack voll
		int* B=new int[2*sz];
		sz !$\leftarrow$! 2*sz;
		for(int i=0; i !$\leq $!;i++){
			B[i] !$\leftarrow $!
		}
		delete[] A;
	}
	A[++t] !$\leftarrow $! x; //eigentlich push
}
int int_stack::pop(){
	if(t==-1){
		EXCEPTION("Leerer Stack")
	return A[t--];
}

\end{lstlisting}
\subsubsection*{Einschub: Variablen, Konstruktoren, Wertzuweisung}
%TODO Einrückung!
\begin{itemize}
\item[Variablen Deklaration] c++: Aufruf des Konstruktors generiert ein Objekt.\\
	Java: Erst eine Referenz erstellen, dann ein Objekt generieren und auf dieses verweisen.
\item[Wertzuweisung] c++: $int_stack s1,s2; s1=s2;$ Objekt wird kopiert, es gibt 2 Objekte.\\
	Java: $int_stack s1,s1; s1=s2;$ Referenzen zeigen auf ein einziges Objekt.
\item[Referenzsemantik in c++:] Verwendet Pointer auf ein Objekt.\\
	Test auf Gleichheit (==) Operator\\
	Parameterübergabe sind Pointer
\item[Referenzsemantik in Java:] Parameter by Value, gesamtes Objekt kopiert und dann übergeben.
\end{itemize}
\subsection*{Korrektheit einer Implementierung}
(Hier der Array-Implementierung von $int_stack$)\\
Eigentlich 2 Datentypen:
\begin{itemize}
\item[1.] der abstrake Datentyp $int_stack$
\item[2.] der konkrete Datentyp Array
\end{itemize}
\underline{Abstrakter Zustand:} Folge von int's\\
\underline{Konkreter Zustand:} Werte der Variable A,t,sz\\
Wir garantieren (Invariante), dass nicht die Kombination von A,t,sz möglich sind, sondern nur gültige Zustande mit:
\begin{itemize}
\item[1.]A ist ein Feld der Länge sz
\item[2.] $-1 \leq t\leq sz-1$
\end{itemize}
Sei Z=Menge der konkreten Zustände und S = Menge der abstrakten Zustände\\
Um die Korrektheit zu zeigen, definieren wir eine Abbildung $F: Z \rightarrow S$\\
$(A,sz,t) \rightarrow \left\lbrace \begin{array}{l}
	Folge\ A[0],...,A[t]\ falls t\geq 0\\
	Leere\ Folge, t=-1
\end{array}\right.$
Und zeigen:
\begin{itemize}
\item[1.] Konstruktoren erzeugen gültige konkrete Zustände
\item[2.] Für jede abstrakte Operation und die dazugehörige konkrete Operation $f_{op}$ zeige $F(f_{op}(Z)) = op(F(Z))$
	Bsp.: push: $S\times int \rightarrow S $\\
	$f_{push}: Z \times int \rightarrow Z$
\end{itemize}
Kommutatives Diagramm:\\
$z \xrightarrow{F} s$\\
$\downarrow f_{op} \uparrow op$\\
$z' \xrightarrow{F} s'$
\subsection*{Vererbung/Generische Datentypen}
Templates/Wiederverwendung von Code\\
\underline{Situation}\\
Man braucht einen Datentyp A, der sehr ähnlich zu einem bereits vorhandenen definierten Typ B ist.\\
A soll:\\
\begin{itemize}
\item einen Teil der Daten/Operationen verwenden
\item andere Daten/Operationen anfügen
\item einige verändern (auf andere Weise implementieren)
\end{itemize}
\subsubsection*{Beispiel}
Es existiert die Klasse Polygon (B), implementiert werden soll eine Klasse Rechteck (A).\\
A ist eine Spezialisierung von B\\
Rechteck könnte alle Polygon-Operationen (draw(),translte etc)\\
Einige Operationen können effizienter implementiert werden (Flächeninhalt etc.)\\
Andere sind nur für Rechtecke definiert.\\
Jedes Rechteck ist ein spezielles Polygon.
\subsubsection*{Allgemein}
Wir leiten die Klasse A von der Klasse B ab.\\
Syntax in c++: A: public B\\
\begin{lstlisting}
class Rechteck: public Polygon{
	//Konstruktoren -> uebung :(
	private:
		//Ueberschreiben
		double b,h;
		double area() {return b*h;}
		double umfang() {return 2*(b+h);}
		//Hinzufuegen
		double ratio() {return b/h;}
};
\end{lstlisting}
Ableitungen auch als Baum darstellbar (Shape mit Kindern Polygon/Ellipse/Punkt etc)\\
\subsubsection*{Typverträglichkeit}
Einer Variable vom Typ B* oder B\& (alle Variablen in JAVA vom Typ B) kann ein Opbjekt (Pointer/Referenz) vom Typ A zugewiesen werden.\\
Alle im Ableitungsbaum erreichbaren Typen können zugewiesen werden (Kinder).\\
Eine Variable hat 2 Typen: Einen Statischen Typ, der zur Compilezeit bekannt ist. Dynamischer Typ, der zur Laufzeit bekannt ist.
\subsection*{Polymorphe Datenstrukturen}
\begin{lstlisting}
polygon* p = new rechteck()
double func(polygon& p){
	return poly.area();}
rechteck rect = new rechteck();
func(rect);
\end{lstlisting}
Es wird per dynamischer Bindung die Funktion func der Klasse Rechteck aufgerufen.\\
C++ benutzt standardmäßig statische Bindung esseidenn Funktion ist "virtual".
Bsp.: Feld von Polygonen\\
c++: Polygon** (Ein Pointer auf ein Feld von Pointern) A = new Polygon*[100];\\
A[0] = new Polygon(...);\\
A[1] = new Rechteck(...);\\
\\
Abstrakte Klassen werden verwendet um Interfaces zu definieren.\\
Z.B. Shape als abstrakte Klasse. In C++ werden Methoden als abstrakt markiert, wenn sie bei der Deklaration = 0 gesetzt werden\\
virtual void draw() = 0;\\
\subsection*{Anwendung auf Algorithmen}
Lineare Ordnungen durch ein Interface umgesetzt.\\
In C++:\\
\begin{lstlisting}
class comparable{
	virtual int compare(compareable x)=0;
}
\end{lstlisting}
Anwendung in generischen Sortieralgorithmen:\\
Quicksort(comparable* A[])\\
Zum Vergleich benutzt man x.compare(y)\\
\subsubsection*{Anwendung: Sortiere ein Feld von point}
\begin{lstlisting}
class point: public comparable{
	int compare(comparable x){
		//x ist tatsaechlich ein point
		double px=((point&)p).x; //Casting
		double py=((point&)p).y;
		//lexikographische Ordnung..
		return ..;
	}
}
Aufruf von Quicksort:
point* A[] = new point*[100];
for(i=0;i<100<i++) A[i] = new point(i,i*i);
Quicksort(A,100);
\end{lstlisting}
Datenstrukturen, bei denen Comparable sinnvoll ist:\\
\begin{itemize}
\item Binäre Suchbäume, bei denen die Knoten vergleichbar sind.
\end{itemize}
\subsubsection*{Weitere Anwendung von Vererbung}
Generische Datenstrukturen wie z.B. Listen von beliebigen Objekten.\\
Einfach verkettete Liste:\\
Beobachtung: Implementierung der Operationen (push, pop), ist nicht abhängig vom Typ. Der Wert (int,string,point,...) jedoch schon.\\
Abstraktion: Liste ohne Werte\\
1. Basisklasse für allgemeines Listenelement:
\begin{lstlisting}
class slist_element{
	slist_element* next;
	slist_element(slist_element* p) {next = p;}
};
\end{lstlisting}
2. Basisklasse für allgemeine List:
\begin{lstlisting}
class slist{
	slist_element* first;
	slist() {first = NULL;}
	
	void push(slist_element* p){
		p->next = first;
		first = p;
	}
	slist_element* pop(){
		if(first == NULL) return first;
		slist_element* p = first;
		first = first.next;
		return p;	
	}
}
\end{lstlisting}
slist funktionirt auch für alle von slist\_elem abgeleiteten Klassen.\\
Besondere Elemente werden als neue Klassen definiert, die von slist\_element erben.\\
Ein "Point" ist ein "slist\_element"\\
\begin{lstlisting}
slist L;
point* p = new point(x,y);
L.push(p);
\end{lstlisting}
slist ist Polymorph, es kann als Liste verschiedener Datentypen dienen.\\
Situationen in denen diese Polymorphie vorteilhaft ist: Grafik-Editor:\\
\begin{lstlisting}
void drawAll() //Iteriere ueber Liste und rufe draw fuer alle auf
forall x in scene //scene ist die Liste
	x -> draw();
\end{lstlisting}
Falls wir eine Liste von einem bestimmten Objekt-Typ verwenden wollen (z.B.b point\_list) wird diese von slist abgeleitet.\\
\begin{lstlisting}
class point_list: public slist {
	//neues Interface das nur points erlaubt
	void push(point* p) {slist::push(p);}
	point* pop(){return (point*) slist::pop();}
	//Das Casting ist sicher, da durch push sicher nur points in der Liste sind.
}
\end{lstlisting}
Aufwändige Datenstruktur: Balancierte Suchbäume (z.B. AVL)\\
1. Klasse für die Knoten (benötigt parent, left, right)
\begin{lstlisting}
class bin_tree_node{
	bin_tree_node* left, right, parent;
};
\end{lstlisting}
2. Klasse für den Baum:
\begin{lstlisting}
class bin_tree{
	virtual int cmp(bin_tree_node* p, bin_tree_node* u) = 0
	//Bsp.: cmp(p,q) = {-1, wenn p<q; 0, wenn p = q; 1, wenn p>q}
	void insert(bin_tree_node* p){
		//fuegt p in den Baum ein, verwendet cmp als Vergleich	
	}
	bin_tree_node* lookup(bin_tree_node* p){
		/* in Schleife: 
		if cmp(q,p) > 0 q=q->left;
			else q=q->right;
			*/
	}
}
\end{lstlisting}
Anwendung auf Point: 
\begin{lstlisting}
class point:public bin_tree_node{
	...
}
class point_bin_tree:public bin_tree{
	//Definiere cmp Funktion
	int cmp(bin_tree_node* p, bin_tree_node* q){
		point* a = (point*)p;
		point* b = (point*)q;
		if(a->x < b->x) return -1;
		if(a->x > b->x) return 1;
		if(a->y < b->y) return -1;
		if(a->y > b->y) return 1;
		return 0;	
	}
	void insert(point* p){
		bin_tree::insert(p);
	}
	point* min() {return (point*)bin_tree::min();}	
}
\end{lstlisting}
\section*{Templates}
\subsection*{Funktionstemplates}
\textit{template $<$class T$>$}\\
Beispiel: swap(T\& x, T\& y) Vertauscht den Inhalt der beiden Variablen\\
\begin{lstlisting}
 swap(T& x, T& y){
 	T tmp = x;
 	x = y;
 	y= tmp;
 }
\end{lstlisting}
Implementierung ist unabhängig von T.
\subsection*{Klassentemplates}
\begin{lstlisting}
template<class T>
class stack{
	T* A; //Feld von T's
	int sz;
	int t;
	
	public
	void push(T x){...}
	T pop {...}
}
\end{lstlisting}
Beispiel für mehrere Typen:
\begin{lstlisting}
template<class K, class I>
class dictionary{
	//Woerterbuch mit Schluessel vom Typ K und werte vom Typ I
	void insert(K k,I i){...}
	I translate (K key){...}
}
\end{lstlisting}
Anwendungsbeispiel: Word-Count, zählt wie oft einzelne Wörter in einem Text vorkommen.
dictionary$<$string,int$?>$ D; Speichert Wort als Schlüssel, Häufigkeit als Wert.
\section*{Fortgeschrittene Datenstrukturen und Algorithmen}
LEDA: Library of Efficient Datatypes and Algorithms\\
Plattform: Algorithmus $\rightarrow$ Programm\\
Datentypen:  Listen, Stacks, Dictionaries, Priority Queue\\
Efficient: Datenstrukturen\\
Einfache Benutzung (Pseudocode soll leicht in C++ umsetzbar sein)\\
Korrektheit: Datentypen (Definition), Program Checker\\
Weitere Themen: Graph-Datenbanken, -Algorithmen, Geometrie\\
\subsection*{Spezifikationen von Datentypen in LEDA}
Item-Konzept: Viele Datentypen sind Definiert als Menge von Items.\\
Item: Zugriff über Parameter (Abstraktion von den Begriffen Pointer, Referenz, Index)\\
Bsp.: dictionary$<string, int>$ D speichert Paare aus Schlüsseln (string) und Informationen (int)\\
Definition: D ist eine Menge von Items (dictionary-Items)\\
Operationen: \\
\begin{itemize}
\item D.insert(string s, int i): Falls D kein Item mit Schlüssel s enthält, füge Item (s,i) ein und gib es zurück. Sonst: Ändere Datenwert i und liefere es zurück.
\item D.lookup(strin s): liefet das Item mit dem Schlüssel s, falls es nicht existiert, Null.
\end{itemize}
2. Beispiel: Priority Queue\\
$priority_queue<P,I> PQ$\\
P: Priorität z.B. Zahl, I: Information (z.B. Knoten eines Graphen)\\
Definition: Menge von Items\\
Operationen: insert, findMin (minimale Priorität), prio (setze Priorität), inf (setze Information), delmin, decrease\_P\\
\subsection*{Dijkstra Algorithmus}
Eingabe: Graph $G=(V,E)$, Kostenfunktion $cost=E\rightarrow int^+$, Startknoten $s\in V$\\
Ausgabe: Distanzfunktion $dist:V\rightarrow int^+$, dist(v) = Kosten eines billigsten Pfades von s nach v.\\
\hspace*{1cm}Kosten eines Pfades: Summe der Kanten.\\
Idee von Dijkstra:\\
\begin{itemize}
\item Überschätze Distanzfunktion: 0, falls s=v, $\inf$, falls $s\neq v$.
\item Kandidatenlist U: Menge aller Knoten, aus deren Kanten ausgehen können, die eine Abkürzung darstellen.
\item Wähle jeweils $u\in U$ mit dist(u) minimal
\item Beobachtung: dist(a) ist korrekt.
\item Durchlaufe alle aus u ausgehenden Kanten und überprüfe Dreiecksungleichung, reduziere Distanz von v
\end{itemize}
Kann effizient mit Fibonacci Heap realisiert werden.
\subsection*{Graphalgorithmen in LEDA}
\subsubsection*{Der Datentyp Graph}
Dient zur Erstellung von gerichteten Graphen G=(V,E) mit $E \subseteq (V \times V)$\\
\subsubsection*{Arten von Objekten}
Operationen auf einem Graphen G:\\
Access Operationen:\\
\hspace*{1cm}node G.source(Edge e): Von welchem Knoten geht die Kante e aus\\
\hspace*{1cm}node G.target(Edge e): Zu welchem Knoten geht die Kante e\\
\hspace*{1cm}int G.outdeg(node v): Ausgangsgrad\\
\hspace*{1cm}int G.indeg(node v): Eingangsgrad\\
\hspace*{1cm}list\textless edge\textgreater G.out\_edges(node v)\\
Update Operationen:\\
\hspace*{1cm}node G.new\_node()\\
\hspace*{1cm}edje G.new\_edge(node v, node w)\\
\hspace*{1cm}void G.del\_edge(edge e)\\
\hspace*{1cm}void G.del\_node(node v) (entfernt v und alle Kanten)\\
Iterationen (Laufvariable wird extern deklariert, weil weil):\\
\hspace*{1cm}forall\_nodes(v,G)\\
\hspace*{1cm}forall\_edges(e,G)\\
\hspace*{1cm}forall\_out\_edges(e,v)\\
\hspace*{1cm}forall\_in\_edges(e,v)\\
Beispiel: Iteration über alle Nachbarknoten von v:\\
\begin{lstlisting}
forall_out_edges(e,v){
	node w = G.target(e)
}
\end{lstlisting}
Beispiel: Teste, ob G azyklisch\\
Idee: Siehe topologisches Sortieren: \\
\hspace*{1cm}Solange ein Knoten v existiert mit indeg(v)=0, entferne ihn und alle ausgehenden Kanten.\\
\hspace*{1cm}Falls G leer, dann ist der Graph azyklisch.
\begin{lstlisting}[escapechar=!]
zero <- {v !$\in$! V | indeg(v) = 0}
while zero !$\neq \emptyset$! do
	u <- beliebiger Knoten aus zero
	zero <- zero\{u}
	forall v !$\in$! V mit (u,v) !$\in$! E
		entferne (u,v) aus G
		if indeg(v)=0 then
			zero <- zero !$\cup$!{u}
		fi
	od
	entferne u aus G
od
\end{lstlisting}
Als C++ Programm (oder auch nicht... Näherliegende Gründe):
\begin{lstlisting}
bool isAcyclic (graph G) //Call by Value, Graph wird kopiert
	stack<node> zero;
	node v;
	forall_nodes(v,G){
		if (G.indeg(v)==0) zero.push(v);
	}
	while (!zero.empty()){
		node u = zero.pop();
		edge e;
		forall_out_edges(e,u){
			node v = G.target(e);
			G.del_edge(e);
			if (G.indeg(v)==0) zero.push(v);
		}
	}
	return G.number_of_edges()==0;
}
\end{lstlisting}
\end{document}
