\documentclass[a4paper]{article}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{fancyhdr}
\usepackage{a4wide}
\usepackage{geometry}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\geometry{a4paper,left=2cm,right=2cm, top=3cm, bottom=3cm}
\usepackage{listings}

\newcommand{\titel}[1]{\fancyhead[C]{#1}}
\newcommand{\name}{\fancyhead[L]{Alexander Landmesser}}
\newcommand{\matrikel}{\fancyhead[R]{}}
\newcommand{\pl}{\hspace*{1cm}}
\begin{document}
\title{Betriebssysteme}
\maketitle
\section{Aufgaben von Betriebssystemen}
\begin{itemize}
\item Zwischen Hardware und Software
\item Effiziente Nutzung der vorhandenen Ressourcen
\item Stelle unendlich Virtuellen Speicher zur Verfügung
\item Isolierte Addressräume für Anwendungen
\item Verhindere Monopolisierung
\end{itemize}
\section{Monolithe und Mikrokerne}
Systemcalls sind im gefährlicher Bereich, eine Anwendung soll keinen direkten Zugriff auf die Hardware haben.\\
Anwendungen benutzen Libraries mit fremden Funktionen.\\
System Call Wrapper bietet eine Funktion, die die Systemaufrufe implementiert.\\
System calls liegen im Kernel, garantiert Schutz der Hardwarefunktionen, da nur über die System Calls Zugriff erlaubt ist.\\
Hardwareinterrupt: Gerät meldet per Leitung/Bit Interrupt. CPU rechnet fertig und bearbeitet diesen Interrupt.\\
System Calls sind Softwareinterrupts.\\
Bei der Ausführung von System calls wechselt das System in den privileged mode und auf den kernel stack. Im privileged mode ist Zugriff auf gefährliche Hardware erlaubt. (Supervisor/Usermode)\\
Nur das Betriebssystem darf im privileged mode laufen und tut dies auch immer, Anwendungen laufen im user mode.
\subsection{Monolithen}
Alle Funktionen des Betriebssystems liegen in einem großen Kernel. D.h. jeder System call wird in diesem einen Kernel ausgeführt.\\
Alle aktuellen Betriebssysteme sind Monolithen.\\
Verbesserung der Entwicklug durch Kernelmodule, die geladen/entladen werden können.
\subsection{Mikrokerne}
Für jede Funktionalität wird ein Mikroserver mit Mikrokern bereitsestellt (File,Grafik, Sound, Speicher etc.)\\
Anfragen werden u.U. durch alle Server geleitet, dabei entstehen für jeden Server Kontextwechse (Zeit!)\\
Kontextwechsel kosten viel Zeit, da bei jedem Kontextwechsel die Caches kalt werden, also keine Treffer besitzen.\\
Verbesserter Ansatz: Entwicklung als Mikrokerne, dadurch leichterer Entwicklung und Wartung. Nach erfolgreichem Testen werden diese Mikrokerne in einen Monolithen integriert und die Adressgrenzen aufgehoben.\\
\section{Virtuelle Maschinen}
Ermöglicht Migration von Virtuellen Maschinen wärend des Betriebs auf andere Hardware.\\
IBM entwickelte VM, da Maschinen zu teuer waren, um die neuen Versionen neben den Produktivsystem zu testen.\\
VMM (Hypervisor, Virtual Machine Monitor) läuft im priviligierten Modus und nimmt die Befehle des Gastsystems an und schickt das erwartete Ergebnis zurück. Das Gastsystem läuft im User-Mode und könnte diese Befehle nicht ausführen. Das Erkennen kritischer Instruktionen ist Aufwändig.\\
Hypervisor (Typ1 VMM): Direkt auf der Hardware, VMM ist quasi Betriebssystem\\
Typ2 VMM: Usermode Anwendungen (VirtualBox, etc.) Application Layer\\
Paravirutalisierung: Angepasste Gastsysteme, die kritische Stellen einem speziellen Hostsystem übergeben.\\
Ausblick: Anwendungen laufen jeweils in eigenen kleinen VM's\\
Immer mehr Anwendungen laufen in Managed Umgebungen (Runtime Environment etc.), also leicht virtualisiert.\\
\section{Architekturansätze}
\subsection{Microsoft Singularity}
Ansatz ein neues System zu entwickeln mit Microkernel, Zuverlässigkeit und modern.\\
Problem der aktuellen OS: Unmanaged Code und deren Zugriff auf den Adressraum. Wenn es nur Managed Software gibt, kann auch das OS managed sein. Speicherzugriff wird von Runtimes gemanaged. Dadurch müssen die Adressräume nicht isoliert werden, es gibt keine teuren Kontextwechsel.\\
Software isoliert Prozesse (SIP): Alles in einem Adressraum, aber Isoliert durch Software.\\
Interprozesskommunikation: Eigene Kommunikationssprache Sing\# entwickelt. Zustandbasierter Ansatz.
Kombiniert Vorteile von Mikrokernel aber umgeht die Schwächen.\\



\end{document}