\documentclass[a4paper]{article}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{fancyhdr}
\usepackage{a4wide}
\usepackage{geometry}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\geometry{a4paper,left=2cm,right=2cm, top=3cm, bottom=3cm}
\usepackage{listings}
\lstset{language=xml}
\newcommand{\oh}[1]{$\mathcal{O}(#1)$}
\newcommand{\titel}[1]{\fancyhead[C]{#1}}
\newcommand{\name}{\fancyhead[L]{Alexander Landmesser}}
\newcommand{\matrikel}{\fancyhead[R]{}}
\newcommand{\pl}{\hspace*{1cm}}
\lstset{literate=
  {á}{{\'a}}1 {é}{{\'e}}1 {í}{{\'i}}1 {ó}{{\'o}}1 {ú}{{\'u}}1
  {Á}{{\'A}}1 {É}{{\'E}}1 {Í}{{\'I}}1 {Ó}{{\'O}}1 {Ú}{{\'U}}1
  {à}{{\`a}}1 {è}{{\`e}}1 {ì}{{\`i}}1 {ò}{{\`o}}1 {ù}{{\`u}}1
  {À}{{\`A}}1 {È}{{\'E}}1 {Ì}{{\`I}}1 {Ò}{{\`O}}1 {Ù}{{\`U}}1
  {ä}{{\"a}}1 {ë}{{\"e}}1 {ï}{{\"i}}1 {ö}{{\"o}}1 {ü}{{\"u}}1
  {Ä}{{\"A}}1 {Ë}{{\"E}}1 {Ï}{{\"I}}1 {Ö}{{\"O}}1 {Ü}{{\"U}}1
  {â}{{\^a}}1 {ê}{{\^e}}1 {î}{{\^i}}1 {ô}{{\^o}}1 {û}{{\^u}}1
  {Â}{{\^A}}1 {Ê}{{\^E}}1 {Î}{{\^I}}1 {Ô}{{\^O}}1 {Û}{{\^U}}1
  {œ}{{\oe}}1 {Œ}{{\OE}}1 {æ}{{\ae}}1 {Æ}{{\AE}}1 {ß}{{\ss}}1
  {ű}{{\H{u}}}1 {Ű}{{\H{U}}}1 {ő}{{\H{o}}}1 {Ő}{{\H{O}}}1
  {ç}{{\c c}}1 {Ç}{{\c C}}1 {ø}{{\o}}1 {å}{{\r a}}1 {Å}{{\r A}}1
  {€}{{\EUR}}1 {£}{{\pounds}}1
}
\lstset{language=c++}
\begin{document}
\title{Netzwerkalgorithmen}
\maketitle
\section{Zusätzliches blabla}
Makros in C/C++: \#define alias replace, wobei replace auch Code sein kann.\\

\section{Datentypen für Graphen und Netzwerke (LEDA)}
\subsection*{Definition eines Datentyps}
Definition der Objekte des Typs: $stack<T>$ \\
Konstruktion: $stack<int>$ S(100) (max Größe)\\
Operationen: $s.push(T x)$, $T s.pop()$\\
Bemerkung zu Implementierung\\
\subsection*{Graph-Datentyp in LEDA}
Der Typ graph repräsentiert gerichtete Graphen.\\
Ein Graph g besteht aus zwei Typen von Objekten: node und edge\\
Mit jedem Knoten v sind zwei Listen von Kanten ($list<edge>$) verbunden (eingehend und ausgehend)\\
Mit jeder Kante e werden 2 Knoten source und target gespeichert.\\
\subsubsection*{Operationen auf G}
Update:\\
\pl node G.new\_node(), erzeugt einen neuen Knoten in G und gibt ihn zurück.
\pl edge G.new\_edge(node v, node w)\\
\pl void G.del\_edge(edge)\\
Access:\\
\pl $list<edge>$ G.out\_edges(node v);\\
\pl int G.outdeg(node v);\\
\pl node G.source(edge);\\
\pl node G.target(edge);\\
Iteration:\\
\pl forall\_nodes(v,G)\\
\pl forall\_edges(e,G)\\
\pl forall\_out\_edges(e,v)\\
\pl forall\_in\_edges(e,v)\\
\subsubsection*{1. Problem}
Gegeben: Graph G=(V,E)\\
Frage: Ist G azyklisch?\\
Algorithmus siehe Topologisches Sortieren: Entferne jeweils einen Knoten v mit indeg(v)=0 bis der Graph leer ist. Falls wir keinen solchen Knoten finden dann ist der Graph zyklisch, falls G am Ende leer, ist er azyklisch.\\
C++:\\
\begin{lstlisting}
bool ACYCLIC(graph G){ 		//Call by value damit G nicht zerstört
	list<node> zero;
	node v;
	forall_nodes(v,G){
		if (G.indeg(v)==0) zero.append(v);
	}
	while (!zero.empty()){
		node u = zero.pop();
		edge e;
		forall_out_edges(e,u){
			node w=G.target(e);
			G.del_edge(e);
			if (G.indeg(w) == 0){
				zero.append(w);
			}
		}
	}
	return G.empty();
}
\end{lstlisting}
\subsubsection*{Daten für Knoten und Kanten}
1. Parametrisierte Graphen: GRAPH$<$node\_type,edge\_type$>$ G\\
2. Temporäre Daten: besucht[v] $\leftarrow$ true
\subsection*{Datentypen in LEDA}
node\_array$<T>$ A(G,x): Feld über die Knoten des Graphen G
edge\_array$<T>$ B(G,y) analog
Verwendet für: Temporäre Daten, Eingabedaten, Resultate\\
\subsubsection*{Anwendung im topologischen Sortieren}
injektive Abbildung: topnum: $V\rightarrow \{1,...,n\}$ mit $\forall (v,w)\in E$: topnum[v]$<$topnum[w]\\
\begin{lstlisting}
bool TOPSORT(const graph& G, node_array<int>& topnum){
	int count = 0;
	list<node> zerol
	node_array<int> indeg(G);
	node v;
	forall_nodes(v,G){
		indeg[v] = G.indeg(v);
		if(indev[v] == 0) zero.append(v);
	}
	while(!zero.empty()){
		node v = zero.pop();
		topnum[v] = ++count;
		edge e;
		forall_out_edges(e,v){
			node w = G.target(e)
			if (--indeg[w] == 0) zero.append(w)
		}
	}
	return count == G.number_of_nodes();
}
\end{lstlisting}
\subsubsection*{Tiefensuche}
Hauptprogramm:
\begin{lstlisting}
void DFS(const graph& G, node_array<int>& dfsnum, node_array<int>& compnum){
	int count1 = 0;
	int count2 = 0;
	node_array<bool> visited(G,false);
	node v;
	forall_nodes(v,G){
		if (!visited[v]) dfs(G,v,count1,count2,dfsnum,compnum)
	}
}
\end{lstlisting}
Rekursive Funktion dfs:
\begin{lstlisting}
void dfs(const graph& g, node v, int& count1, int& count2,node_array<int>& dfsnum, _
		node_array<int>& compnum){
	dfsnum[v] == ++count1;
	visited[v] = true;
	edge e;
	forall_out_edges(e,v){
		edge w = G.target(e),
		if(!visited[w]) dfs(G,w,count1,count2,dfsnum,compnum)
	}
	compnum[v] = ++count2
}
\end{lstlisting}
\subsubsection*{Berechnung starker Zusammenhangskomponenten}
Definition: Ein gerichteter Graph ist stark zusammenhängend, wenn $\forall v,w \ in V: v\rightarrow^* w$ (es existiert ein Pfad von v nach w)\\
Die starken Zusammenhangskomponenten (SZK) von G sind die maximalen SZK Teilgraphen von G.\\
Idee für Algorithmus:\\
\begin{enumerate}
\item führe DFS mit $G'=(V',E')$ dem Teilgraphen aufgespannt von bereits besuchten Knoten
\item Verwalte SZK von $G'$ während DFS ausgeführt wird.
\end{enumerate}
Ablauf:\\
Sei (v,w) die nächste in dfs betrachtete Kante\\
1. Fall: $(v,w)\in T$ (Baumkante), w noch nicht besucht.  $V' = V'\cup \{w\}, E' = E'\cup \{(v,w)\},SZK=SZK\cup \{\{w\}\}$\\
2. Fall: $(v,w)\not\in T$,d.h. w wurde schon besucht, ist also in $V'$ enthalten.$E'=E'\cup\{(v,w)\}$. Nun kann (v,w) meherere bereits bekannte SZK vereinigen (Rückwärtskante oder Cross-Kante). Bemerkung: Vorwärtskanten generieren keine neuen Pfade in $G'$, deswegen dabei keine änderung der SZK.\\
Bezeichnungen:\\
\begin{enumerate}
\item Eine SKZ K heißt abgeschlossen, falls die Aufrufe von dfs für alle Knoten v in K beendet sind.
\item Die Wurzel einer SZK K ist der Knoten mit der kleinsten dfsnum in K.
\item "Unfertig" ist die Folge aller Knoten für die dfs aufgerufen wurde, aber deren SZK in der sie sich befinden noch nicht abgeschlossen ist.
\item "Wurzeln" ist die Folge aller Wurzeln der nicht abgeschlossenen SZK nach dfsnum sortiert.
\end{enumerate}
Situation, wenn DFS beim Knoten g angekommen ist:\\
%TODO Beispiel hier
Unfertig: a,b,c,e,f,g\\
Wurzeln: 1,b,e,g\\
Der Algorithmus betrachtet danach dei Kanten aus g $(g,d)\in C$: es passiert nichts, da d in einer abgeschlossenen SZK ist;$(g,c)\in C$ Vereinigt die 3 SZK mit den Wurzeln b,e,g durch entfernen von e,g aus der Wurzelfolge.\\
Beobachtung: Hinzufügen und Streichen nur am Ende $\rightarrow$ Stack eignet sich als Datenstruktur.\\
Allgemeine Situation für $(v,w)\in T$:\\
%TODO Bild
$K' = K_2\cup K_3\cup K_4$.\\
\begin{tabular}{c|c|c|c}
$K_1$&$K_2$&$K_3$&$K_4$\\
$r_1$|||&$r_2$|||&$r_3$|||&$r_4$|||\\
\end{tabular}\\
Ergänzungen von DFS für SZK:\\
1. Aktion: while dfsum[wurzel.top()] $>$ dfsnum[w] do wurzeln.pop() od\\
2. Falls $(v,w)\in T$: Wurzeln.push(w); Unfertig.push(v)\\
3. Abschluss eine SZK: SZK von v wird endgültig verlassen, sie ist nun abgeschlossen.\\
\pl Am Ende von dfs(v): if v == Wurzel.top() then \\
\pl \pl Wurzeln.pop();\\
\pl \pl repeat w = unfertig.pop() until w==v\\
\pl fi\\
Übung 2: Algo zu SZK.
\end{document}
