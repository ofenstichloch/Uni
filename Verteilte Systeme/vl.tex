\documentclass[a4paper]{article}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{fancyhdr}
\usepackage{a4wide}
\usepackage{geometry}
\usepackage[utf8]{inputenc}
\geometry{a4paper,left=2cm,right=2cm, top=3cm, bottom=3cm}
\usepackage{listings}

\newcommand{\titel}[1]{\fancyhead[C]{#1}}
\newcommand{\name}{\fancyhead[L]{Alexander Landmesser}}
\newcommand{\matrikel}{\fancyhead[R]{}}
\newcommand{\pl}{\hspace*{1cm}}
\begin{document}
\title{Verteilte Systeme}
\maketitle
\section{ØMQ}
\subsection{Verwendung}
\begin{itemize}
\item[1. Context:] Es muss für ØMQ ein Kontext erstellt werden (das Umfeld)
\item[2. Socket:] Es muss ein Socket in diesem Kontext erstellt werden
\item[3. Sockettyp:] Was für eine Art Socket wird benötigt (SUB/PUB etc.)
\item[4. Binding:] Socket an eine Adresse und einen Port binden (Remote, oder Lokale für listening)
\item[5.1 Receive] Receive (blockierend), besonderer Messagetyp
\item[5.2 Send] Send, gegebener Messagetyp ist zu füllen

\end{itemize}
ØMQ Buffert alle Nachrichten bis zu einem gewissen Grad. So werden auch langsamere Reader oder später registrierte Subscriber bedient, jedoch ohne versicherung, dass sie alle Nachrichten empfangen.
\subsection{Patterns}
\begin{itemize}
\item[Request-Reply] Synchrone Request-Reply Kommunikation
\item[Push-Pull] Sender erwartet keine Rückantwort (Push), Empfänger benutzen Pull, um Nachricht zu empfangen.\\
Kann benutzt werden, um Lasten zu verteilen, weil eine Nachricht nur höchstens eimal empfangen werden kann.
\item[Pub/Sub] Ein Publisher sendet Nachrichten mit bestimmten Tags, alle Subscriber empfangen alle Nachrichten, die den vorgegebenen Tags des Subscribers entsprechen.
\end{itemize}
\subsection{Transportvarianten}
\begin{itemize}
\item[ipc:] Interprozess, FIFO etc.
\item[inproc:] Socketkommunikation innerhalb eines Prozesses.
\item[mMulticast:] ØMQ unterstützt Multicast, wenn das Netzwerk es unterstützt.
\end{itemize}
\subsection{PlayØMQ, Broker}
Sources generieren Zufallszahlen und geben sie an den Broker.\\
Worker nehmen Zahlen aus dem Broker und prüfen auf Primzahl.\\
Sinks hören auf Nummern/Primzahlen.
Broker: Sendet einkommende Zahlen per Push-Socket an Worker, sendet Zahlen und Primzahlen per PUB-Socket
Source: Request Reply auf Broker.\\
Worker: Push/Pull $\rightarrow$ Parallelisierung der Berechnung \\
Sink: Subscriber, die auf den Broker "Subscriben", mit dem entsprechenden Tag (number/primzahl)
\subsubsection{Nachrichten}
Senden und Empfangen von Daten muss besonders behandelt werden, da Nachrichten erstellt werden müssen.\\
Nachrichten bestehen aus Tag (identifier Char) und Wert (long)
\subsubsection{Source}
Benötigt URL von Broker\\
Erstelle REQ (Request) Socket, der mit dem Broker verbindet.\\
Source generiert Zahlen, sendet sie an Broker und wartet, bis dieser den Empfang bestätigt hat.
\subsubsection{Broker}
Broker hat Sockets für REP (Reply) für Source, PUB (Publisher) für Sinks, PUSH für Worker.\\
Im Beispiel ist Endpoint eine Methode, die die Befehle zum Erstellen eines einfachen Sockets zusammenfasst.\\
Broker empfängt Zahl von Source, bestätigt dem Empfang, publiziert die Nummer, sendet sie an die Worker, wartet auf die Antwort und publiziert u.U. die Primzahl.
\subsubsection{Worker}
Verbindet per PULL und REQ (Request) Socket auf den Broker. \\
Empfängt vom Broker per PULL Zahlen, prüft diese und sendet sie u.U. per REQ an Broker. Wenn die Primzahl gesendet wird, muss der Worker wieder auf die Antwort (REPly) des Broker warten.
\subsubsection{Sink}
Erstellt SUB (Subscriber) Socket, über den er vom Broker Daten empfängt. \\
Beim Erstellen wird festgelegt, auf welche Tags der Subscriber hört.\\
\section{Verteilung von Last}

Kreative Lastverteilung: Verteilte Programmierung.\\
Mechanische Lastverteilung: Verteilung auf Rechner, gleiche Auslastung der verwendeten Rechner\\

Durch verteilte Rechner ist die "aktuelle Last" verzögert, um die Latenz zwischen A und B. A schickt also Last an B, auch wenn B inzwischen eine hohe Last erreicht hat.\\
Lösung: A kann anhand der verteilten Last merken, wie viel Last ungefähr an B vergeben wurde (wenn B Last nicht weitergibt).\\

Paketweitergabe:\\
\begin{itemize}
\item Wenn der Code lokal vorhanden ist, muss er kopiert werden (achte auf identische Pfadnamen etc.)\\
	Bei Netzwerklaufwerken geht Zeit verloren, da das Netzwerklaufwerk limitierende Bandbreite hat.
\item Verteiler schickt Programmcode mit (Große Datenmenge, Achtung Viren)

\end{itemize}

\subsection{Architektur}
Erstellen einer Lastmetrik: Welche Last hat ein Rechner, welche Last erzeugt ein Paket?\\
Verteilung der Last der beteiligten Rechner: Entscheidungsgundlage für Verteiler.\\
Verteilung des Lastpaketes auf gewählte Rechner: Welche Informationen müssen übertragen werden.\\
\subsection*{Lastmetriken}
\begin{itemize}
\item Prozessorauslastung (Anzahl Prozesse, CPU-Zeit)
\item Speicherauslastung (Bedarf etc.)
\item Kommunikationslast (IO, Netzwerk)
\end{itemize}
\subsubsection*{Pull}
Zieht Lastwerten an. (Unterforderte Rechner suchen Last)\\
Lastwert wird bei der Erzeugung eines Paketes ermittelt.\\
Varianten:
\begin{itemize}
\item[Von allen Rechnern:] Verteiler sendet Broadcast und fragt nach Last, alle Rechner antworten mit eignener Last.\\
	Verbesserung: Antowrt wird verzögert, je nach eigener Last. Damit antwortet der am wenigsten ausgelastete als erstes.
\item[Feste Teilmenge:] Erreriche bestimmte Worker
\item[Zufällige Teilmenge:]Frage zufällige Worker an
\end{itemize}
\subsubsection*{Push}
Lastwerte verteilen.  (Überforderte Rechner verteilen Last)\\

\subsection{Verteilungsverfahren}
Last sollte so verteilt werden, dass Rechen- und Speicherlast gleich verteilt ist und die Kommunikation möglichst lokal stattfindet.
\begin{itemize}
\item[Statisches Verfahren] Optimale Verteilung vor dem Start der Anwendung ermitteln.\\ 
Alle Bestandteile der Lastmetrik sind für alle Prozesse bekannt.\\
Findet häufig Anwendung, Last ist vorher meistens bekannt (Meterologie etc.)
\item[Dynamisches Verfahren] Ausführungsort wird für jeden Prozess ermittelt. 
	\begin{itemize}
	\item[Mit Migration] Migration heißt, die Adressräume und die Prozessstati zu übertragen. Es muss gewartet werden, bis alle Threads keine OS-Ressourcen mehr benutzen.\\
	Problem: Adressräume sind u.U. sehr groß. \\
	Lösung: Copy-on-Reference: Kopiere Adressen, wenn sie benötigt werden. (Reduziert Speicherlast auf Quellknoten nicht).
	\item[Ohne Migration] Hoher Aufwand die Lastverteilung zu bestimmen.
	\end{itemize}
\end{itemize}
Durchgesetzt hat sich \underline{Initial Placement}\\
Bei Paketentstehung Zielknoten bestimmen, im Extremfall zufällige Wahl.\\
Ist durchaus das schnellste Verfahren.\\

\end{document}
